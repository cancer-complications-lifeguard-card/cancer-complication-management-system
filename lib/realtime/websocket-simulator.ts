/**
 * WebSocket Simulator for Demo Purposes
 * Simulates WebSocket functionality using HTTP polling for development/demo
 * In production, this would be replaced with actual WebSocket implementation
 */

export interface SimulatedWebSocketMessage {
  type: string;
  timestamp: number;
  userId: number;
  data: any;
}

export class WebSocketSimulator {
  private static instance: WebSocketSimulator;
  private isConnected = false;
  private pollingInterval: NodeJS.Timeout | null = null;
  private messageHandlers: Map<string, Function[]> = new Map();
  private userId = 0;
  private lastPollTime = 0;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;

  private constructor() {}

  static getInstance(): WebSocketSimulator {
    if (!WebSocketSimulator.instance) {
      WebSocketSimulator.instance = new WebSocketSimulator();
    }
    return WebSocketSimulator.instance;
  }

  /**
   * Simulate WebSocket connection using HTTP polling
   */
  async connect(userId: number): Promise<void> {
    this.userId = userId;
    this.isConnected = false;

    try {
      // Test connection
      const response = await fetch('/api/realtime?type=status');
      if (!response.ok) {
        throw new Error('Failed to connect to realtime API');
      }

      this.isConnected = true;
      this.reconnectAttempts = 0;
      this.startPolling();
      
      console.log('WebSocket Simulator connected (HTTP polling mode)');
      
      // Notify connection handlers
      this.notifyHandlers('connection', {
        status: 'connected',
        mode: 'http-polling',
        userId
      });
    } catch (error) {
      console.error('WebSocket Simulator connection failed:', error);
      this.scheduleReconnect();
    }
  }

  /**
   * Disconnect and stop polling
   */
  disconnect(): void {
    this.isConnected = false;
    
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = null;
    }

    console.log('WebSocket Simulator disconnected');
    
    this.notifyHandlers('connection', {
      status: 'disconnected'
    });
  }

  /**
   * Subscribe to message types
   */
  subscribe(messageType: string, handler: Function): void {
    if (!this.messageHandlers.has(messageType)) {
      this.messageHandlers.set(messageType, []);
    }
    this.messageHandlers.get(messageType)!.push(handler);
  }

  /**
   * Unsubscribe from message types
   */
  unsubscribe(messageType: string, handler: Function): void {
    const handlers = this.messageHandlers.get(messageType);
    if (handlers) {
      const index = handlers.indexOf(handler);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    }
  }

  /**
   * Send message (simulate by calling API)
   */
  async send(message: SimulatedWebSocketMessage): Promise<void> {
    if (!this.isConnected) {
      console.warn('Cannot send message: not connected');
      return;
    }

    try {
      const response = await fetch('/api/realtime', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          type: message.type,
          data: message.data
        })
      });

      if (response.ok) {
        const result = await response.json();
        
        // Handle any alerts generated by the server
        if (result.alerts && result.alerts.length > 0) {
          for (const alert of result.alerts) {
            this.notifyHandlers('alert', alert);
          }
        }
      }
    } catch (error) {
      console.error('Failed to send message:', error);
    }
  }

  /**
   * Send vital signs data
   */
  async sendVitalSigns(userId: number, data: any): Promise<void> {
    await this.send({
      type: 'vital-signs',
      timestamp: Date.now(),
      userId,
      data
    });
  }

  /**
   * Send device status
   */
  async sendDeviceStatus(userId: number, deviceId: string, status: string): Promise<void> {
    await this.send({
      type: 'device-status',
      timestamp: Date.now(),
      userId,
      data: {
        deviceId,
        status,
        timestamp: Date.now()
      }
    });
  }

  /**
   * Check if connected
   */
  isConnectedState(): boolean {
    return this.isConnected;
  }

  /**
   * Get connection state
   */
  getConnectionState(): string {
    return this.isConnected ? 'connected' : 'disconnected';
  }

  /**
   * Start polling for demo data
   */
  private startPolling(): void {
    if (this.pollingInterval) return;

    // Poll every 30 seconds for demo purposes
    this.pollingInterval = setInterval(() => {
      this.pollForDemoData();
    }, 30000);

    // Also do an initial poll
    setTimeout(() => this.pollForDemoData(), 2000);
  }

  /**
   * Poll for demo data to simulate real-time updates
   */
  private async pollForDemoData(): Promise<void> {
    if (!this.isConnected) return;

    try {
      // Occasionally simulate receiving data or alerts for demo
      const shouldSimulate = Math.random() < 0.3; // 30% chance
      
      if (shouldSimulate) {
        const simulationType = Math.random() < 0.7 ? 'data' : 'alert';
        
        const response = await fetch(`/api/realtime?type=simulate-${simulationType}`);
        if (response.ok) {
          const result = await response.json();
          
          // Notify appropriate handlers
          this.notifyHandlers(result.type, result.data);
        }
      }
    } catch (error) {
      console.error('Error during polling:', error);
      
      // If polling fails multiple times, try to reconnect
      this.reconnectAttempts++;
      if (this.reconnectAttempts >= 3) {
        this.disconnect();
        this.scheduleReconnect();
      }
    }
  }

  /**
   * Notify message handlers
   */
  private notifyHandlers(messageType: string, data: any): void {
    const handlers = this.messageHandlers.get(messageType);
    if (handlers) {
      const message = {
        type: messageType,
        timestamp: Date.now(),
        userId: this.userId,
        data
      };
      
      handlers.forEach(handler => {
        try {
          handler(message);
        } catch (error) {
          console.error('Error in message handler:', error);
        }
      });
    }
  }

  /**
   * Schedule reconnection attempt
   */
  private scheduleReconnect(): void {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnection attempts reached');
      return;
    }

    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
    console.log(`Scheduling reconnect in ${delay}ms (attempt ${this.reconnectAttempts + 1})`);

    setTimeout(() => {
      console.log('Attempting to reconnect...');
      this.connect(this.userId);
    }, delay);
  }
}

// Export singleton instance
export const websocketSimulator = WebSocketSimulator.getInstance();

// Override the websocket manager for demo purposes
if (typeof window !== 'undefined') {
  // Patch the websocket manager to use the simulator
  import('./websocket-manager').then(({ websocketManager }) => {
    const originalConnect = websocketManager.connect;
    const originalSend = websocketManager.send;
    const originalIsConnected = websocketManager.isConnected;
    const originalGetConnectionState = websocketManager.getConnectionState;
    const originalDisconnect = websocketManager.disconnect;

    // Override methods to use simulator
    (websocketManager as any).connect = async (userId: number) => {
      return websocketSimulator.connect(userId);
    };

    (websocketManager as any).send = async (message: any) => {
      return websocketSimulator.send(message);
    };

    (websocketManager as any).sendVitalSigns = async (userId: number, data: any) => {
      return websocketSimulator.sendVitalSigns(userId, data);
    };

    (websocketManager as any).sendDeviceStatus = async (userId: number, deviceId: string, status: string) => {
      return websocketSimulator.sendDeviceStatus(userId, deviceId, status);
    };

    (websocketManager as any).isConnected = () => {
      return websocketSimulator.isConnectedState();
    };

    (websocketManager as any).getConnectionState = () => {
      return websocketSimulator.getConnectionState();
    };

    (websocketManager as any).disconnect = () => {
      return websocketSimulator.disconnect();
    };

    (websocketManager as any).subscribe = (messageType: string, handler: Function) => {
      return websocketSimulator.subscribe(messageType, handler);
    };

    (websocketManager as any).unsubscribe = (messageType: string, handler: Function) => {
      return websocketSimulator.unsubscribe(messageType, handler);
    };

    console.log('WebSocket Manager patched to use HTTP polling simulator');
  });
}